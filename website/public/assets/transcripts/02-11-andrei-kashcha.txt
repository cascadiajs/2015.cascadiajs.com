      >> Hello, friends.  Can you see this text well?  I don't know.  Something has happened.  And I cannot see anything.
      Better?  Is it good?  Cool.  Thank you.  It still looks somewhat strange.  I don't know. The font looks not normal.  And I swear I had the feeling like... I had the feeling like the letters were chasing my mouse cursor. And I don't know. Wait. No.  No.  What's happening? That's not normal.  Can you please stop chasing my mouse cursor, font? No, wait. No font, I need you to show slides and text and... No please.  Stop!  Oh.  Okay.  Thank you, font!
      My friends, I want to invite you today for a journey.  A journey from a single request animation frame to visualization of huge graphs.  And along the way, we will stop to visit visualization of popular package managers.
      Similar to how every visualization, erm sorry, every journey starts with a single step, every visualization starts with request animation frame.
      requestAnimationFrame is just a browser API.  It takes one function, a callback.  The browser will call your callback before next repaint event.  Normally you would use this API like so.  You will ask the browser to call your callback.  And then inside the callback, you will keep asking the browser to call you over and over again.  And this will form infinite rendering loop.
      Inside this rendering loop, you will update your scene. You will move the particles to do something here.  But browser will try to call you as fast as 60 times per second. Or 60 times per 1,000 milliseconds.  Which means all you have here inside this function is just 16 milliseconds.  It needs to be super fast.  And the fastest rendering technology today in the Web is called WebGL.  WebGL is very, very powerful, very fast technology.  But it also requires a lot of code to get started with.
      I'm going to be using three.js, which is built on top of WebGL. It's very powerful too. And its JavaScript library.  But it also requires some coding.  Less than raw WebGL, but some code.  So for the sake of simplicity, I'm going to hide three.js behind an interface so that we can focus on the journey.  With that in mind, let me show you the first example.
      In this example we have requestAnimationFrame.  requestAnimationFrame will call our callback, and then we keep calling ourself.  And inside the callback, we render the scene.  In this example we're rendering particles.  Particle are just dots on the screen.  So here we set X and Y coordinates of the particle to the random position.  And if you open this in the browser, the browser calls our API 60 times per second and every time it calls us, we update the position of the particle. So it's random movement. This is expected. This is normal.
      Now, let's refactor this code a little bit.  Let's extract this particle initialization into the JavaScript object.  So now the particle is an object, which has X and Y coordinates. It's just normal JavaScript object. We set it to the random position once its created. And since nobody is updating this, if we open this in the browser, the particles are stopped. Nobody is moving X and Y, the browser still calls us 60 times per second.  Now, let's ask these particles to chase our mouse cursor.
      To do so, now we are learning to the regular DOM event: 'mousemove'.  And every time you move mouse, we set a new target: X and Y.  This is ideal target for the particle.  So each particle will try to follow towards that coordinate.  Now, if you open this in the browser -- you see particles are chasing our mouse cursor.  And this is exactly the secret behind the chasing font. And you see I'm moving particles here inside requestAnimationFrame.
      Alright, now we know how to render particles using requestAnimationFrame.  This is good.  And to recap a little bit.  The requestAnimationFrame is just the browser API. Its being called 60 times per second, and it needs to be very, very fast.
      So now let's talk about graphs.  Graphs are just data structures.  They have nodes (this pink vertices here), and edges.  Connections between nodes. Right? These white lines.  But how do you render graphs on the screen?  We know how to render particles. If you render these nodes at random positions, we'll end up with mess.  This is hard to understand.  And there's no structure visible here.  So how do we go from this mess into this nice little structure?  How do we even explain to the browser what is "nice looking"?
      Turns out that there are several metrics which we can address.  First, we want to reduce the amount of intersections.  The smaller amount of intersections we have, the less clutter it's going to be on the final layout.
      Then, if the connection between the two nodes have the same strength, there's no reason why they should have different length.  They should be the same.  And finally, if the algorithm could detect the symmetries on the graph our eye could catch structure much easier and much faster.  So this is the same graph, yet you see the structure immediately.  So how do we solve all these three problems together?
      Before we go to the solution, I wanted to relax a little bit and look at this peaceful image of nature...  And it also turns out that nature has the answer to our problem.  If we pretend for a second that every node of the graph is a charged particle, then according to the Coulomb's law -- they will repel each other.  And then if you pretend that every connection between the particle is a spring, then according to the Hooke's law they will be held together.
      Now, these are two competing forces.  On one hand the repulsive force tries to pull them apart, and on the other hand the contracting force doesn't let them fly far away.  So it's like a battle of the two forces.  This battle of the forces is encoded within this npm module.  And this npm module takes just one argument.  A graph.  Now, if you want to perform one iteration of this physical simulation, of this battle, we just call layout.step().
      And if somebody wants to get the position of the node at any moment of time, they could say: "Layout give me the position for this node ID.  For this node". Right?  Or if you want to combine this layout algorithm with requestAnimationFrame, we can do it like so.  Now we will perform iteration of the physical simulation inside the requestAnimationFrame.  And we will see visualization of the forces' battle.  Let me show you.
      Now, you see repulsive forces trying to pull the particles away, apart, and then springs, they hold them together.  They do not let them fly far away.  And you see that the nature solved our problems.  It detected all the symmetries.  It tries to keep the length of the links the same, and it also reduced the amount of intersections on this graph.
      But let me focus your attention on something very special on this slide. Something very, very important.  requestAnimationFrame still has only 16 milliseconds.  We just added more work and still we have 16 milliseconds.  If we go beyond that point, we will be very, very slow.
      So how do we fit the force based layout within the 16 milliseconds?  Because the bigger the graph you get, the slower it's going to become.  Somebody suggested use a "speed up" separator.  This operator, they said, is going to work for Java, C++. It's just this forward slash.
      I tried to use it and, again, this is not good.  It's hard to understand.  So speed-up operator is not really an answer.
      But honestly, it took me almost two years to find this obvious solution.  How to help our force based algorithm to escape the 16 millisecond window.  And the solution is very, very simple.  It's not magical at all.  So we just put the computation of the layout on the server.  So now the server can do exactly the same what we saw before.  The server will get this module and then perform 200 maybe 500 iterations of this battle and then compute the forces for each of the particle.  And finally it will save the results to the disk. For each node it will save X, Y, Z, coordinates to the disk.
      Now, the browser can download this file just once, and use this array of X, Y, Z, coordinates to position every single node.  With this approach, you can render really, really large graphs.
      And our first large graph today is bower.  None of these graphs were shown before in public, and this was created specially for you guys.  Bower has more than 30,000 packages.  And this is how it looks like.  Every white dot here is a bower package.  We can fly away here and see structure within the bower.  The size of each node here means the number of dependencies.  So the bigger your size, the more popular you are the more packages are using you.  So immediately you see in Bower there are two very popular packages.  What are they?  This is jQuery with 4,000 dependences.  Can anybody guess what's the other one here?
      Lodash I hear. Well, all right.  Let's see what this is.  This is angular.  Also you can see that if you fly far away from the main cluster here, there's a star field.  All these packages were pulled away from these repulsive forces because they have no dependencies, nobody holds them in the main cluster.  So they just moved out; right?
      But also you can see that the structure, it has theselittle mushrooms over here. So all of them have just one dependency.  This dependency is usually very popular package. In this example this dependency is angular. Angular holds this little cloud of packages, and the contracting force doesn't let them fly far away.  It just holds them there.  Similar to the jQuery.  jQuery has its own cloud here.  But you also probably noticed that there's this large, large mushroom here, which has no large dot inside.  So something else is holding them there.  And what is this?  This was huge surprise to me when I saw this first time. Let's check it out.
      You see that nobody -- there's no dependency for this package.  Yet somebody is using all these packages.  So there is a package in the Bower community which has dependencies on all these little dots. And what is that package? Let me show you.  The package is called 'everything'.
      [Laughter]
      >> Everything has 15,000 packages... Depends on 15,000 packages.  And the package was created a year ago and wasn't updated since then.  So the Bower grew and grew, and it grew, and you see the progress of Bower here on this graph.  What's also fascinating about the everything, and the Bower community, maybe in general, not community, the ecosystem, the everything depends on this little guy.
      [Laughter]
      A pile of poo.  Speaking of singular responsibility principle, I wonder what's the responsibility of this package.  Unfortunately, I couldn't find this package in the register anymore, but everything still depends on it.  It just came through the dependency of everything.
      So this is Bower.  But you probably noticed that something was missing on this graph.  Graph has vertices and edges.  We only showed dots.  We didn't show the edges.  Where are the edges?  And why we didn't show them?  So let me show you why.
      This is how it would look like if you would render all the edges.  It's beautiful.  It has lots of edges inside, but it's hard to see the structure there, and also this is one of the reasons that people criticize force based layouts.  They say that most natural graphs have this hair ball there, and it's very hard to understand the structure behind this hair ball.
      So this is not very special to Bower.  Let me show you how it looks like on the PHP's composer graph.  PHP's composer package manager has more than 60,000 dependencies. And now we're going to see it, for the first time, with all the connections rendered inside of the graph.  So this is PHP graph.  It is beautiful.  But it's useless.  You cannot see the structure within the... within this graph.
      So what should we do?  We can hide the links and now see the mushrooms as well in the Bower and see the most popular packages within the PHP world.  But once we hide the links, we will also lose something.  We will lose the beauty of these little fellow here, these little constellations which are pushed away from the main cluster.  They're just beautiful.  They have all sorts of different structures there.  And I really want to see them.
      So I was looking at this graph two weeks ago.  Very, very sad.  How something beautiful like this could be so useless?
      [Laughter]
      So I hopped into my spaceship and flew outside of this galaxy to the edge of the universe, and I was flying here looking at these little fellows, exploring them, and then suddenly... Boom! The idea came into my mind.  That's the sound of ideas in my mind.
      What if instead of rendering every possible connection inside this graph, we would only render those links whose length is smaller than 200 pixels? Or maybe 100 pixels?  What would we see?
      Let me show you what I saw.  Now, this is the same graph.  But now the clutter is gone.  You see communities within the package manager.  It's incredibly beautiful.  You can explore all these little fellows here and also see that the far away stars... you can still explore them.
      This visualization works really nice on this desktop.  I'm using Mac here, and it's a very powerful computer.  But what about the our smaller friends?  The mobile phone.  Would it work in the mobile phone?  And does the mobile phone support WebGL?  My friends, if you have Android or iPhone with you, I invite you to test with me.  Just grab your phone and go to this URL.  I will do it with you.
      So here you see a list of all package manager which are currently available.  Just for fun, I will pick the largest graph.  The visualization of Go packages.  Which currently has 180,000 packages.  A little bit more than that.  All right.  So now you see the dots.  With one finger touch, I can fly forward.  And with two fingers touch, I can fly backward.
      And using my mouse, err just regular phone, just by rotating it, I can control the camera here. Like so.  So this is 200,000, almost 200,000 packages rendered on the mobile phone.
      This tool was not released publically, and I'm not sure if you're experiencing bugs or anything. Do you even see this on your phones?
      [clapping]
      Okay.  That's good.  I see the blank screen.  I think it's not good.  So this approach is really fast.  But how fast is it?  Can we see the numbers of really how many frames per second we're going to get from this approach to visualize large graphs?
      Let me show you the numbers.  On the next slide, we will see visualizations of popular package managers.  Side by side.  Composer, with its 65,000 dependencies; Ruby gems with 90,000 dependencies; npm with 163,000 dependencies; and Go with 182,000 packages.  Ready?  So this is visualization of all these package managers.  And this is FPS.  Most of them are rendered at 60 frame per second.  So this is very, very fast.  And looking at these graphs, several realizations came into my mind.  First the graphs are just absolutely amazing.  They have all sorts of little galaxies within them, little communities and hidden modules, which are super fun to explore.  And second we need to visualize something else.
      Because it's just not enough packages in all these package managers to get us to one million nodes graph.  But also all of these little dots on the screen, they're not just dots, they're part of someone's life! A human being they just took part of their life and created the package and published it there.  So... humans are very interesting species.  And developers are also interesting.
      [Laughter]
      We as developers, we have all sorts of different connections.  Some of these connections are encoded on GitHub; right?  We follow each other.  And I wanted to see this following information.
      So our last stop today is one million node graph.  It took me several weeks to download the data from GitHub, and compute the layout. And this is shown just first time for you here.  Nobody else saw this before.  So let's see what's going to happen.
      The data set is probably 20 megabytes, so it takes some time to download.  And this is, ladies and gentlemen, the GitHub.
      [clapping]
      So let's explore.  All these white dots are just human beings, which is incredible powerful thing.  So what is this large here?  Who is he?  Let's see if I can focus on him.  Come on.  Yes.  This is Linus Torvalds. What about the this guy here?  Who is he?  This is TJ. He has 15,000 followers.  And what about these large stars in this cluster?  Who is this guy? This is Mojombo. So I believe he's the one who started GitHub; right?  And what about the this guy?  This is Scott with 10,000 followers.
      So all these people here, they all work for GitHub.  Which makes me think if you want to have lots of followers in GitHub, you need to start GitHub.  And then, similar to have we saw in package managers the satellite clouds of people who follow just one package, here we have satellites of users who follow just one person.  So this is a cloud which follows Mojombo. Who is this?  This is a cloud which follows Scott and -- you see there are lots of them here.  For example, what's this?  Followers of defunkt.  Now, let's enable links for a second.  With enabled links, you can see hidden communities in the GitHub.  This is not seen before.  So all these people, they have similar amount of followers.  But they follow most of the same people within this group.  And there are so many groups like this inside the whole GitHub.  You can see them all here.  And I think one of the largest surprises on the GitHub for me was this large green hair ball.  So all these people, they still follow each other and nobody else.  But why?  What makes it so special to these people?  Why do they follow each other?  I don't know.  And this visualization doesn't tell you.  It let's you ask these questions.  Why?
      So how many nodes does this visualization have?  Let me show you.  This graph has 1,117,000 nodes. I indexed only those people who has more than two followers. Because otherwise it would take me more than two weeks.
      So, my friends, today we started our journey from requestAnimationFrame, and then we helped the force based layout to escape the 16 millisecond window.  And then we defeated this hair ball monster and saw the hidden communities within the graphs of package managers.  And finally this visualization of GitHub concluds our journey into the graphs today.  But it will continue on this repository.  So thank you very much, guys.
      [clapping] 
